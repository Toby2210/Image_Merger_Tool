<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "免費線上圖片合併工具",
    "url": "https://Toby2210.github.io/",
    "description": "使用此工具調整間距、排序並下載合併圖片。支援 JPG/PNG, 無需註冊。",
    "applicationCategory": "PhotoEditing",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    }
  }
  </script>
  <meta property="og:title" content="免費線上圖片合併工具 - 快速合併多張圖片">
  <meta property="og:description" content="使用此工具調整間距、排序並下載合併圖片。支援 JPG/PNG, 無需註冊。">
  <meta property="og:image" content="https://Toby2210.github.io/preview.jpg">
  <meta property="og:url" content="https://Toby2210.github.io/">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="免費線上圖片合併工具 - 快速合併多張圖片">
  <meta name="twitter:description" content="使用此工具調整間距、排序並下載合併圖片。支援 JPG/PNG, 無需註冊。">
  <meta name="twitter:image" content="https://Toby2210.github.io/preview.jpg">
  <link rel="canonical" href="https://Toby2210.github.io/">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4925437706750304"
     crossorigin="anonymous"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>免費線上圖片合併工具 - 快速合併多張圖片</title>
  <meta name="description" content="使用此工具調整間距、排序並下載合併圖片。支援 JPG/PNG, 無需註冊。">
  <meta name="keywords" content="圖片合併, 線上合併圖片, 免費圖片工具"> 
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      background-color: #f0f0f0;
    }
    #preview {
      margin-top: 20px;
      max-width: 100%;
      border: 1px solid #ccc;
      cursor: move;
      touch-action: none;
    }
    .button-container {
      margin: 20px 0;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    button, input[type="file"], input[type="number"] {
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    input[type="file"], button {
      cursor: pointer;
      background-color: #007bff;
      color: white;
    }
    input[type="number"] {
      width: 100px;
      background-color: #fff;
    }
    button:hover, input[type="file"]:hover {
      background-color: #0056b3;
    }
    input[type="number"]:focus {
      outline: none;
      border: 2px solid #007bff;
    }
    #downloadButton {
      display: none;
      margin-top: 20px;
      background-color: #28a745;
      color: white;
      border-radius: 5px;
    }
    #downloadButton:hover {
      background-color: #218838;
    }
    .dragging {
      opacity: 0.7;
      border: 2px dashed #007bff;
    }
    .drop-target {
      border: 2px solid #007bff;
    }
    #dragPreview {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      max-width: 100px;
      max-height: 100px;
      opacity: 0.8;
      border: 2px solid #007bff;
      border-radius: 5px;
    }
    #dragLabel {
      position: fixed;
      pointer-events: none;
      z-index: 1001;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 12px;
      padding: 2px 5px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>免費線上圖片合併工具</h1>
  <p>使用此工具調整間距、排序並下載合併圖片。支援 JPG/PNG, 無需註冊。</p>
  <h2>功能</h2>
  <ul>
    <li>合併多張圖片</li>
    <li>調整圖片間距</li>
    <li>下載高品質結果</li>
  </ul>
  <div class="button-container">
    <input type="file" id="imageInput" accept="image/*" multiple>
    <label for="imagesPerRow">每行圖片數量：</label>
    <input type="number" id="imagesPerRow" min="0" value="0" title="輸入每行圖片數量（0 表示所有圖片一行）">
    <label for="rowSpacing">行間距（像素）：</label>
    <input type="number" id="rowSpacing" min="0" value="0" title="輸入行之間的間距">
    <label for="colSpacing">列間距（像素）：</label>
    <input type="number" id="colSpacing" min="0" value="0" title="輸入列之間的間距">
    <button onclick="mergeImages('asc')">按名稱正序合併</button>
    <button onclick="mergeImages('desc')">按名稱倒序合併</button>
  </div>
  <canvas id="preview"></canvas>
  <button id="downloadButton" onclick="downloadMergedImage()">下載合併圖片</button>

  <script>
    let canvasDataUrl = ''; // 儲存畫布數據 URL
    let imageFiles = []; // 儲存選取的檔案
    let imagePositions = []; // 儲存圖片在畫布上的位置
    let images = []; // 儲存載入的圖片物件
    let draggedIndex = -1; // 追蹤拖動的圖片索引
    let isDragging = false; // 追蹤是否正在拖動

    // 處理檔案輸入變化以初始化圖片，並按名稱正序合併
    document.getElementById('imageInput').addEventListener('change', async (event) => {
      imageFiles = Array.from(event.target.files);
      if (imageFiles.length === 0) return;

      // 按名稱正序排序
      imageFiles = imageFiles.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
      images = await Promise.all(imageFiles.map(file => loadImage(file)));
      await mergeImages('asc');
    });

    // 處理間距和每行圖片數量輸入變化，重新繪製畫布
    document.getElementById('rowSpacing').addEventListener('input', () => {
      if (images.length > 0) mergeImages('custom');
    });
    document.getElementById('colSpacing').addEventListener('input', () => {
      if (images.length > 0) mergeImages('custom');
    });
    document.getElementById('imagesPerRow').addEventListener('input', () => {
      if (images.length > 0) mergeImages('custom');
    });

    // 在畫布上繪 ترکیب圖片並儲存位置
    function drawImages(ctx, images, imagesPerRow, rowSpacing, colSpacing, highlightIndex = -1, dropTargetIndex = -1) {
      imagePositions = [];
      let maxRowWidth = 0;
      let totalHeight = rowSpacing; // 為第一行上方添加行間距
      let currentRowWidth = 0;
      let currentRowHeight = 0;
      let rowWidths = [];
      let rowHeights = [];
      let currentRowImages = 0;
      let xOffset = 0;
      let yOffset = rowSpacing; // 初始 yOffset 為行間距
      let rowIndex = 0;
      let imagesInCurrentRow = 0;

      images.forEach((img) => {
        if (imagesPerRow > 0 && currentRowImages >= imagesPerRow) {
          // 每行包含所有圖片的列間距
          rowWidths.push(currentRowWidth + (currentRowImages - 1) * colSpacing);
          rowHeights.push(currentRowHeight);
          maxRowWidth = Math.max(maxRowWidth, currentRowWidth + (currentRowImages - 1) * colSpacing);
          totalHeight += currentRowHeight + rowSpacing; // 包含下方行間距
          currentRowWidth = 0;
          currentRowHeight = 0;
          currentRowImages = 0;
        }
        currentRowWidth += img.width;
        currentRowHeight = Math.max(currentRowHeight, img.height);
        currentRowImages++;
      });

      if (currentRowImages > 0) {
        rowWidths.push(currentRowWidth + (currentRowImages - 1) * colSpacing);
        rowHeights.push(currentRowHeight);
        maxRowWidth = Math.max(maxRowWidth, currentRowWidth + (currentRowImages - 1) * colSpacing);
        totalHeight += currentRowHeight;
      }

      // 設置畫布尺寸
      ctx.canvas.width = maxRowWidth;
      ctx.canvas.height = totalHeight;

      // 清除畫布以保持透明背景
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // 繪製間距的白色背景
      images.forEach((img, index) => {
        if (imagesPerRow > 0 && imagesInCurrentRow >= imagesPerRow) {
          xOffset = 0;
          yOffset += rowHeights[rowIndex] + rowSpacing; // 包含上方行間距
          rowIndex++;
          imagesInCurrentRow = 0;
        }

        // 繪製圖片及其間距區域的白色背景
        ctx.fillStyle = '#ffffff';
        // 繪製圖片區域
        ctx.fillRect(xOffset, yOffset, img.width, img.height);
        // 繪製右側列間距（除了每行最後一張圖片）
        if (imagesInCurrentRow < (imagesPerRow || images.length) - 1) {
          ctx.fillRect(xOffset + img.width, yOffset, colSpacing, img.height);
        }
        // 繪製第一行或每行上方的行間距
        if (imagesInCurrentRow === 0) {
          ctx.fillRect(0, yOffset - rowSpacing, maxRowWidth, rowSpacing);
        }

        if (index !== highlightIndex) {
          ctx.drawImage(img, xOffset, yOffset, img.width, img.height);
        }
        imagePositions.push({
          index,
          x: xOffset,
          y: yOffset,
          width: img.width,
          height: img.height
        });
        if (index === highlightIndex) {
          ctx.globalAlpha = 0.5;
          ctx.drawImage(img, xOffset, yOffset, img.width, img.height);
          ctx.globalAlpha = 1.0;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.font = '12px Arial';
          ctx.fillText(imageFiles[index].name, xOffset, yOffset + img.height - 5);
        }
        if (index === dropTargetIndex) {
          ctx.strokeStyle = '#007bff';
          ctx.lineWidth = 2;
          ctx.strokeRect(xOffset, yOffset, img.width, img.height);
        }
        xOffset += img.width + colSpacing; // 每張圖片後增加列間距
        imagesInCurrentRow++;
      });

      return { maxRowWidth, totalHeight, rowWidths, rowHeights };
    }

    // 根據畫布座標找到圖片索引，考慮縮放比例
    function getImageAtPosition(x, y, canvas) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const canvasX = x * scaleX;
      const canvasY = y * scaleY;
      return imagePositions.findIndex(pos =>
        canvasX >= pos.x && canvasX <= pos.x + pos.width &&
        canvasY >= pos.y && canvasY <= pos.y + pos.height
      );
    }

    async function mergeImages(order) {
      const input = document.getElementById('imageInput');
      const imagesPerRowInput = document.getElementById('imagesPerRow');
      const rowSpacingInput = document.getElementById('rowSpacing');
      const colSpacingInput = document.getElementById('colSpacing');
      const canvas = document.getElementById('preview');
      const ctx = canvas.getContext('2d');
      const downloadButton = document.getElementById('downloadButton');
      let files = imageFiles.length > 0 ? imageFiles : Array.from(input.files);

      if (files.length === 0) {
        alert('請先選擇圖片！');
        return;
      }

      let imagesPerRow = parseInt(imagesPerRowInput.value) || 0;
      if (imagesPerRow < 0) imagesPerRow = 0;
      let rowSpacing = parseInt(rowSpacingInput.value) || 0;
      if (rowSpacing < 0) rowSpacing = 0;
      let colSpacing = parseInt(colSpacingInput.value) || 0;
      if (colSpacing < 0) colSpacing = 0;

      if (order === 'asc') {
        files = files.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        imageFiles = files;
        images = await Promise.all(files.map(file => loadImage(file)));
      } else if (order === 'desc') {
        files = files.sort((a, b) => b.name.toLowerCase().localeCompare(a.name.toLowerCase()));
        imageFiles = files;
        images = await Promise.all(files.map(file => loadImage(file)));
      }

      drawImages(ctx, images, imagesPerRow, rowSpacing, colSpacing);

      canvasDataUrl = canvas.toDataURL('image/png');
      downloadButton.style.display = 'inline-block';
    }

    // 處理畫布上的拖放
    const canvas = document.getElementById('preview');
    let startX, startY;
    let dragPreview = null;
    let dragLabel = null;

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      draggedIndex = getImageAtPosition(startX, startY, canvas);
      if (draggedIndex !== -1) {
        isDragging = true;
        canvas.classList.add('dragging');

        // 創建拖動預覽圖片
        dragPreview = document.createElement('img');
        dragPreview.id = 'dragPreview';
        dragPreview.src = images[draggedIndex].src;
        document.body.appendChild(dragPreview);

        // 創建拖動標籤
        dragLabel = document.createElement('div');
        dragLabel.id = 'dragLabel';
        dragLabel.textContent = imageFiles[draggedIndex].name;
        document.body.appendChild(dragLabel);

        const ctx = canvas.getContext('2d');
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0, draggedIndex);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const targetIndex = getImageAtPosition(x, y, canvas);

      // 更新拖動預覽位置
      if (dragPreview) {
        dragPreview.style.left = `${e.clientX + 10}px`;
        dragPreview.style.top = `${e.clientY + 10}px`;
      }
      if (dragLabel) {
        dragLabel.style.left = `${e.clientX + 10}px`;
        dragLabel.style.top = `${e.clientY + 30}px`;
      }

      const ctx = canvas.getContext('2d');
      drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                 parseInt(document.getElementById('rowSpacing').value) || 0,
                 parseInt(document.getElementById('colSpacing').value) || 0, draggedIndex, targetIndex);
    });

    canvas.addEventListener('mouseup', async (e) => {
      if (!isDragging) return;
      isDragging = false;
      canvas.classList.remove('dragging');
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const targetIndex = getImageAtPosition(x, y, canvas);
      if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
        // 交換圖片
        [images[draggedIndex], images[targetIndex]] = [images[targetIndex], images[draggedIndex]];
        [imageFiles[draggedIndex], imageFiles[targetIndex]] = [imageFiles[targetIndex], imageFiles[draggedIndex]];
        const ctx = canvas.getContext('2d');
        // 重新計算畫布尺寸並繪製
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0);
        canvasDataUrl = canvas.toDataURL('image/png');
      }
      draggedIndex = -1;
      // 移除拖動預覽和標籤
      if (dragPreview) {
        dragPreview.remove();
        dragPreview = null;
      }
      if (dragLabel) {
        dragLabel.remove();
        dragLabel = null;
      }
      // 確保最終畫布重新繪製
      const ctx = canvas.getContext('2d');
      drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                 parseInt(document.getElementById('rowSpacing').value) || 0,
                 parseInt(document.getElementById('colSpacing').value) || 0);
    });

    canvas.addEventListener('mouseleave', () => {
      if (isDragging) {
        isDragging = false;
        canvas.classList.remove('dragging');
        draggedIndex = -1;
        if (dragPreview) {
          dragPreview.remove();
          dragPreview = null;
        }
        if (dragLabel) {
          dragLabel.remove();
          dragLabel = null;
        }
        const ctx = canvas.getContext('2d');
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0);
      }
    });

    // 保留拖放事件作為備用
    canvas.addEventListener('dragstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      draggedIndex = getImageAtPosition(x, y, canvas);
      if (draggedIndex !== -1) {
        e.dataTransfer.setData('text/plain', draggedIndex);
        canvas.classList.add('dragging');
        dragPreview = document.createElement('img');
        dragPreview.id = 'dragPreview';
        dragPreview.src = images[draggedIndex].src;
        document.body.appendChild(dragPreview);
        dragLabel = document.createElement('div');
        dragLabel.id = 'dragLabel';
        dragLabel.textContent = imageFiles[draggedIndex].name;
        document.body.appendChild(dragLabel);
        const ctx = canvas.getContext('2d');
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0, draggedIndex);
      }
    });

    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const targetIndex = getImageAtPosition(x, y, canvas);
      if (dragPreview) {
        dragPreview.style.left = `${e.clientX + 10}px`;
        dragPreview.style.top = `${e.clientY + 10}px`;
      }
      if (dragLabel) {
        dragLabel.style.left = `${e.clientX + 10}px`;
        dragLabel.style.top = `${e.clientY + 30}px`;
      }
      if (targetIndex !== -1) {
        const ctx = canvas.getContext('2d');
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0, draggedIndex, targetIndex);
      }
    });

    canvas.addEventListener('dragend', () => {
      canvas.classList.remove('dragging');
      draggedIndex = -1;
      if (dragPreview) {
        dragPreview.remove();
        dragPreview = null;
      }
      if (dragLabel) {
        dragLabel.remove();
        dragLabel = null;
      }
      const ctx = canvas.getContext('2d');
      drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                 parseInt(document.getElementById('rowSpacing').value) || 0,
                 parseInt(document.getElementById('colSpacing').value) || 0);
    });

    canvas.addEventListener('drop', async (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const targetIndex = getImageAtPosition(x, y, canvas);
      if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
        // 交換圖片
        [images[draggedIndex], images[targetIndex]] = [images[targetIndex], images[draggedIndex]];
        [imageFiles[draggedIndex], imageFiles[targetIndex]] = [imageFiles[targetIndex], imageFiles[draggedIndex]];
        const ctx = canvas.getContext('2d');
        // 重新計算畫布尺寸並繪製
        drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                   parseInt(document.getElementById('rowSpacing').value) || 0,
                   parseInt(document.getElementById('colSpacing').value) || 0);
        canvasDataUrl = canvas.toDataURL('image/png');
      }
      draggedIndex = -1;
      canvas.classList.remove('dragging');
      if (dragPreview) {
        dragPreview.remove();
        dragPreview = null;
      }
      if (dragLabel) {
        dragLabel.remove();
        dragLabel = null;
      }
      // 確保最終畫布重新繪製
      const ctx = canvas.getContext('2d');
      drawImages(ctx, images, parseInt(document.getElementById('imagesPerRow').value) || 0,
                 parseInt(document.getElementById('rowSpacing').value) || 0,
                 parseInt(document.getElementById('colSpacing').value) || 0);
    });

    async function downloadMergedImage() {
      const canvas = document.getElementById('preview');
      try {
        if ('showSaveFilePicker' in window) {
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: 'merged_image.png',
            types: [{
              description: 'PNG Image',
              accept: { 'image/png': ['.png'] }
            }]
          });
          const writable = await fileHandle.createWritable();
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
          await writable.write(blob);
          await writable.close();
        } else {
          const link = document.createElement('a');
          link.href = canvasDataUrl;
          link.download = 'merged_image.png';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      } catch (err) {
        console.error('下載失敗:', err);
        alert('無法保存文件，可能是因為瀏覽器不支持或用戶取消了操作。請重試。');
        const link = document.createElement('a');
        link.href = canvasDataUrl;
        link.download = 'merged_image.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }
  </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'95c6df36d898b0d5',t:'MTc1MjA1NDE1Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>